\hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}{}\doxysection{tainicom.\+Aether.\+Physics2\+D.\+Collision.\+Dynamic\+Tree$<$ T $>$ Class Template Reference}
\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}\index{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}}


A dynamic tree arranges data in a binary tree to accelerate queries such as volume queries and ray casts. Leafs are proxies with an \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}}. In the tree we expand the proxy \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}} by Settings.\+b2\+\_\+fat\+AABBFactor so that the proxy \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}} is bigger than the client object. This allows the client object to move by small amounts without triggering a tree update.  


\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_af7b0eabf058ebd2551617d6a4a85686e}{Dynamic\+Tree}} ()
\begin{DoxyCompactList}\small\item\em Constructing the tree initializes the node pool. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a6b9fdf6dae436c1f9d4089f62b4bccf5}{Add\+Proxy}} (ref \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}} aabb)
\begin{DoxyCompactList}\small\item\em Create a proxy in the tree as a leaf node. We return the index of the node instead of a pointer so that we can grow the node pool. ~\newline
 /// \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a2bec2185e5b0d157067c370f7f51323c}{Remove\+Proxy}} (int proxy\+Id)
\begin{DoxyCompactList}\small\item\em Destroy a proxy. This asserts if the id is invalid. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_addf172ec5c146b53876d3b1c46136182}{Move\+Proxy}} (int proxy\+Id, ref \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}} aabb, \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_common_1_1_vector2}{Vector2}} displacement)
\begin{DoxyCompactList}\small\item\em Move a proxy with a swepted \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}}. If the proxy has moved outside of its fattened \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}}, then the proxy is removed from the tree and re-\/inserted. Otherwise the function returns immediately. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_abec85eb21b177f36645e7e11ac673aa0}{Set\+User\+Data}} (int proxy\+Id, T user\+Data)
\begin{DoxyCompactList}\small\item\em Set proxy user data. \end{DoxyCompactList}\item 
T \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a804d6a3eaa9062dcc32cae5abb9d7ef1}{Get\+User\+Data}} (int proxy\+Id)
\begin{DoxyCompactList}\small\item\em Get proxy user data. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a9c752aa02648d375da23a41b3dc3781f}{Get\+Fat\+AABB}} (int proxy\+Id, out \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}} fat\+AABB)
\begin{DoxyCompactList}\small\item\em Get the fat \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}} for a proxy. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}} \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a407ff7c2ece7ba153342f8b634aae2ac}{Get\+Fat\+AABB}} (int proxy\+Id)
\begin{DoxyCompactList}\small\item\em Get the fat \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}} for a proxy. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_abb840b71f7cb04c96c79f5c55134f5be}{Test\+Fat\+AABBOverlap}} (int proxy\+IdA, int proxy\+IdB)
\begin{DoxyCompactList}\small\item\em Test overlap of fat AABBs. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a0ce037a5d3d1a4140fc8969ef709cfe3}{Query}} (Broad\+Phase\+Query\+Callback callback, ref \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}} aabb)
\begin{DoxyCompactList}\small\item\em Query an \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}} for overlapping proxies. The callback class is called for each proxy that overlaps the supplied \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a47022000b096c1499d6dc8de731f0e7f}{Ray\+Cast}} (Broad\+Phase\+Ray\+Cast\+Callback callback, ref \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_ray_cast_input}{Ray\+Cast\+Input}} input)
\begin{DoxyCompactList}\small\item\em Ray-\/cast against the proxies in the tree. This relies on the callback to perform a exact ray-\/cast in the case were the proxy contains a Shape. The callback also performs the any collision filtering. This has performance roughly equal to k $\ast$ log(n), where k is the number of collisions and n is the number of proxies in the tree. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a5856bf1308cc5231dd99ced8d98374be}{Compute\+Height}} (int node\+Id)
\begin{DoxyCompactList}\small\item\em Compute the height of a sub-\/tree. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a2f06e47bef9a5d3302bd6d64b3dc6caa}{Compute\+Height}} ()
\begin{DoxyCompactList}\small\item\em Compute the height of the entire tree. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a844177c4a22fd6579a89d892cb316685}\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a844177c4a22fd6579a89d892cb316685}} 
void {\bfseries Validate\+Structure} (int index)
\item 
\mbox{\Hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_aa75619d9c0d687501b95a18c222d1ad7}\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_aa75619d9c0d687501b95a18c222d1ad7}} 
void {\bfseries Validate\+Metrics} (int index)
\item 
void \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_ac6629f6cf40323a6ed7b339d26f02fb3}{Validate}} ()
\begin{DoxyCompactList}\small\item\em Validate this tree. For testing. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_acd88f74eab4ea863af1895613d30c1e5}{Rebuild\+Bottom\+Up}} ()
\begin{DoxyCompactList}\small\item\em Build an optimal tree. Very expensive. For testing. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_aeb7515316a5be319b1f5bd2301c3c0db}{Shift\+Origin}} (\mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_common_1_1_vector2}{Vector2}} new\+Origin)
\begin{DoxyCompactList}\small\item\em Shift the origin of the nodes \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Properties}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_ac5973aefbe658d2fc285fc1fba3e4426}{Height}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Compute the height of the binary tree in O(\+N) time. Should not be called often. \end{DoxyCompactList}\item 
float \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_abc970b94d79de90b525e1c06118aeb02}{Area\+Ratio}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Get the ratio of the sum of the node areas to the root area. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a6e68eb87b6fd9f4cddf818d014c5de62}{Max\+Balance}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Get the maximum balance of an node in the tree. The balance is the difference in height of the two children of a node. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
A dynamic tree arranges data in a binary tree to accelerate queries such as volume queries and ray casts. Leafs are proxies with an \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}}. In the tree we expand the proxy \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}} by Settings.\+b2\+\_\+fat\+AABBFactor so that the proxy \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}} is bigger than the client object. This allows the client object to move by small amounts without triggering a tree update. 

Nodes are pooled and relocatable, so we use node indices rather than pointers.

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_af7b0eabf058ebd2551617d6a4a85686e}\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_af7b0eabf058ebd2551617d6a4a85686e}} 
\index{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}!DynamicTree@{DynamicTree}}
\index{DynamicTree@{DynamicTree}!tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{DynamicTree()}{DynamicTree()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}{tainicom.\+Aether.\+Physics2\+D.\+Collision.\+Dynamic\+Tree}}$<$ T $>$.\mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}{Dynamic\+Tree}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Constructing the tree initializes the node pool. 



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a6b9fdf6dae436c1f9d4089f62b4bccf5}\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a6b9fdf6dae436c1f9d4089f62b4bccf5}} 
\index{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}!AddProxy@{AddProxy}}
\index{AddProxy@{AddProxy}!tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{AddProxy()}{AddProxy()}}
{\footnotesize\ttfamily int \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}{tainicom.\+Aether.\+Physics2\+D.\+Collision.\+Dynamic\+Tree}}$<$ T $>$.Add\+Proxy (\begin{DoxyParamCaption}\item[{ref \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}}}]{aabb }\end{DoxyParamCaption})}



Create a proxy in the tree as a leaf node. We return the index of the node instead of a pointer so that we can grow the node pool. ~\newline
 /// 


\begin{DoxyParams}{Parameters}
{\em aabb} & The aabb.\\
\hline
{\em user\+Data} & The user data.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Index of the created proxy
\end{DoxyReturn}
\mbox{\Hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a2f06e47bef9a5d3302bd6d64b3dc6caa}\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a2f06e47bef9a5d3302bd6d64b3dc6caa}} 
\index{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}!ComputeHeight@{ComputeHeight}}
\index{ComputeHeight@{ComputeHeight}!tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{ComputeHeight()}{ComputeHeight()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily int \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}{tainicom.\+Aether.\+Physics2\+D.\+Collision.\+Dynamic\+Tree}}$<$ T $>$.Compute\+Height (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Compute the height of the entire tree. 

\begin{DoxyReturn}{Returns}
The height of the tree.
\end{DoxyReturn}
\mbox{\Hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a5856bf1308cc5231dd99ced8d98374be}\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a5856bf1308cc5231dd99ced8d98374be}} 
\index{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}!ComputeHeight@{ComputeHeight}}
\index{ComputeHeight@{ComputeHeight}!tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{ComputeHeight()}{ComputeHeight()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily int \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}{tainicom.\+Aether.\+Physics2\+D.\+Collision.\+Dynamic\+Tree}}$<$ T $>$.Compute\+Height (\begin{DoxyParamCaption}\item[{int}]{node\+Id }\end{DoxyParamCaption})}



Compute the height of a sub-\/tree. 


\begin{DoxyParams}{Parameters}
{\em node\+Id} & The node id to use as parent.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The height of the tree.
\end{DoxyReturn}
\mbox{\Hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a407ff7c2ece7ba153342f8b634aae2ac}\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a407ff7c2ece7ba153342f8b634aae2ac}} 
\index{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}!GetFatAABB@{GetFatAABB}}
\index{GetFatAABB@{GetFatAABB}!tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{GetFatAABB()}{GetFatAABB()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}} \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}{tainicom.\+Aether.\+Physics2\+D.\+Collision.\+Dynamic\+Tree}}$<$ T $>$.Get\+Fat\+AABB (\begin{DoxyParamCaption}\item[{int}]{proxy\+Id }\end{DoxyParamCaption})}



Get the fat \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}} for a proxy. 


\begin{DoxyParams}{Parameters}
{\em proxy\+Id} & The proxy id.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The fat \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}}.
\end{DoxyReturn}
\mbox{\Hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a9c752aa02648d375da23a41b3dc3781f}\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a9c752aa02648d375da23a41b3dc3781f}} 
\index{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}!GetFatAABB@{GetFatAABB}}
\index{GetFatAABB@{GetFatAABB}!tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{GetFatAABB()}{GetFatAABB()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}{tainicom.\+Aether.\+Physics2\+D.\+Collision.\+Dynamic\+Tree}}$<$ T $>$.Get\+Fat\+AABB (\begin{DoxyParamCaption}\item[{int}]{proxy\+Id,  }\item[{out \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}}}]{fat\+AABB }\end{DoxyParamCaption})}



Get the fat \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}} for a proxy. 


\begin{DoxyParams}{Parameters}
{\em proxy\+Id} & The proxy id.\\
\hline
{\em fat\+AABB} & The fat \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}}.\\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a804d6a3eaa9062dcc32cae5abb9d7ef1}\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a804d6a3eaa9062dcc32cae5abb9d7ef1}} 
\index{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}!GetUserData@{GetUserData}}
\index{GetUserData@{GetUserData}!tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{GetUserData()}{GetUserData()}}
{\footnotesize\ttfamily T \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}{tainicom.\+Aether.\+Physics2\+D.\+Collision.\+Dynamic\+Tree}}$<$ T $>$.Get\+User\+Data (\begin{DoxyParamCaption}\item[{int}]{proxy\+Id }\end{DoxyParamCaption})}



Get proxy user data. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em proxy\+Id} & The proxy id.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the proxy user data or 0 if the id is invalid.
\end{DoxyReturn}
\mbox{\Hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_addf172ec5c146b53876d3b1c46136182}\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_addf172ec5c146b53876d3b1c46136182}} 
\index{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}!MoveProxy@{MoveProxy}}
\index{MoveProxy@{MoveProxy}!tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{MoveProxy()}{MoveProxy()}}
{\footnotesize\ttfamily bool \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}{tainicom.\+Aether.\+Physics2\+D.\+Collision.\+Dynamic\+Tree}}$<$ T $>$.Move\+Proxy (\begin{DoxyParamCaption}\item[{int}]{proxy\+Id,  }\item[{ref \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}}}]{aabb,  }\item[{\mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_common_1_1_vector2}{Vector2}}}]{displacement }\end{DoxyParamCaption})}



Move a proxy with a swepted \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}}. If the proxy has moved outside of its fattened \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}}, then the proxy is removed from the tree and re-\/inserted. Otherwise the function returns immediately. 


\begin{DoxyParams}{Parameters}
{\em proxy\+Id} & The proxy id.\\
\hline
{\em aabb} & The aabb.\\
\hline
{\em displacement} & The displacement.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the proxy was re-\/inserted.
\end{DoxyReturn}
\mbox{\Hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a0ce037a5d3d1a4140fc8969ef709cfe3}\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a0ce037a5d3d1a4140fc8969ef709cfe3}} 
\index{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}!Query@{Query}}
\index{Query@{Query}!tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{Query()}{Query()}}
{\footnotesize\ttfamily void \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}{tainicom.\+Aether.\+Physics2\+D.\+Collision.\+Dynamic\+Tree}}$<$ T $>$.Query (\begin{DoxyParamCaption}\item[{Broad\+Phase\+Query\+Callback}]{callback,  }\item[{ref \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}}}]{aabb }\end{DoxyParamCaption})}



Query an \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}} for overlapping proxies. The callback class is called for each proxy that overlaps the supplied \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_a_a_b_b}{AABB}}. 


\begin{DoxyParams}{Parameters}
{\em callback} & The callback.\\
\hline
{\em aabb} & The aabb.\\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a47022000b096c1499d6dc8de731f0e7f}\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a47022000b096c1499d6dc8de731f0e7f}} 
\index{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}!RayCast@{RayCast}}
\index{RayCast@{RayCast}!tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{RayCast()}{RayCast()}}
{\footnotesize\ttfamily void \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}{tainicom.\+Aether.\+Physics2\+D.\+Collision.\+Dynamic\+Tree}}$<$ T $>$.Ray\+Cast (\begin{DoxyParamCaption}\item[{Broad\+Phase\+Ray\+Cast\+Callback}]{callback,  }\item[{ref \mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_ray_cast_input}{Ray\+Cast\+Input}}}]{input }\end{DoxyParamCaption})}



Ray-\/cast against the proxies in the tree. This relies on the callback to perform a exact ray-\/cast in the case were the proxy contains a Shape. The callback also performs the any collision filtering. This has performance roughly equal to k $\ast$ log(n), where k is the number of collisions and n is the number of proxies in the tree. 


\begin{DoxyParams}{Parameters}
{\em callback} & A callback class that is called for each proxy that is hit by the ray.\\
\hline
{\em input} & The ray-\/cast input data. The ray extends from p1 to p1 + max\+Fraction $\ast$ (p2 -\/ p1).\\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_acd88f74eab4ea863af1895613d30c1e5}\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_acd88f74eab4ea863af1895613d30c1e5}} 
\index{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}!RebuildBottomUp@{RebuildBottomUp}}
\index{RebuildBottomUp@{RebuildBottomUp}!tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{RebuildBottomUp()}{RebuildBottomUp()}}
{\footnotesize\ttfamily void \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}{tainicom.\+Aether.\+Physics2\+D.\+Collision.\+Dynamic\+Tree}}$<$ T $>$.Rebuild\+Bottom\+Up (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Build an optimal tree. Very expensive. For testing. 

\mbox{\Hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a2bec2185e5b0d157067c370f7f51323c}\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a2bec2185e5b0d157067c370f7f51323c}} 
\index{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}!RemoveProxy@{RemoveProxy}}
\index{RemoveProxy@{RemoveProxy}!tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{RemoveProxy()}{RemoveProxy()}}
{\footnotesize\ttfamily void \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}{tainicom.\+Aether.\+Physics2\+D.\+Collision.\+Dynamic\+Tree}}$<$ T $>$.Remove\+Proxy (\begin{DoxyParamCaption}\item[{int}]{proxy\+Id }\end{DoxyParamCaption})}



Destroy a proxy. This asserts if the id is invalid. 


\begin{DoxyParams}{Parameters}
{\em proxy\+Id} & The proxy id.\\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_abec85eb21b177f36645e7e11ac673aa0}\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_abec85eb21b177f36645e7e11ac673aa0}} 
\index{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}!SetUserData@{SetUserData}}
\index{SetUserData@{SetUserData}!tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{SetUserData()}{SetUserData()}}
{\footnotesize\ttfamily void \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}{tainicom.\+Aether.\+Physics2\+D.\+Collision.\+Dynamic\+Tree}}$<$ T $>$.Set\+User\+Data (\begin{DoxyParamCaption}\item[{int}]{proxy\+Id,  }\item[{T}]{user\+Data }\end{DoxyParamCaption})}



Set proxy user data. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em proxy\+Id} & The proxy id.\\
\hline
{\em user\+Data} & The proxy user data.\\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_aeb7515316a5be319b1f5bd2301c3c0db}\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_aeb7515316a5be319b1f5bd2301c3c0db}} 
\index{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}!ShiftOrigin@{ShiftOrigin}}
\index{ShiftOrigin@{ShiftOrigin}!tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{ShiftOrigin()}{ShiftOrigin()}}
{\footnotesize\ttfamily void \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}{tainicom.\+Aether.\+Physics2\+D.\+Collision.\+Dynamic\+Tree}}$<$ T $>$.Shift\+Origin (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structtainicom_1_1_aether_1_1_physics2_d_1_1_common_1_1_vector2}{Vector2}}}]{new\+Origin }\end{DoxyParamCaption})}



Shift the origin of the nodes 


\begin{DoxyParams}{Parameters}
{\em new\+Origin} & The displacement to use.\\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_abb840b71f7cb04c96c79f5c55134f5be}\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_abb840b71f7cb04c96c79f5c55134f5be}} 
\index{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}!TestFatAABBOverlap@{TestFatAABBOverlap}}
\index{TestFatAABBOverlap@{TestFatAABBOverlap}!tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{TestFatAABBOverlap()}{TestFatAABBOverlap()}}
{\footnotesize\ttfamily bool \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}{tainicom.\+Aether.\+Physics2\+D.\+Collision.\+Dynamic\+Tree}}$<$ T $>$.Test\+Fat\+AABBOverlap (\begin{DoxyParamCaption}\item[{int}]{proxy\+IdA,  }\item[{int}]{proxy\+IdB }\end{DoxyParamCaption})}



Test overlap of fat AABBs. 


\begin{DoxyParams}{Parameters}
{\em proxy\+IdA} & The proxy id A.\\
\hline
{\em proxy\+IdB} & The proxy id B.\\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_ac6629f6cf40323a6ed7b339d26f02fb3}\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_ac6629f6cf40323a6ed7b339d26f02fb3}} 
\index{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}!Validate@{Validate}}
\index{Validate@{Validate}!tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{Validate()}{Validate()}}
{\footnotesize\ttfamily void \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}{tainicom.\+Aether.\+Physics2\+D.\+Collision.\+Dynamic\+Tree}}$<$ T $>$.Validate (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Validate this tree. For testing. 



\doxysubsection{Property Documentation}
\mbox{\Hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_abc970b94d79de90b525e1c06118aeb02}\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_abc970b94d79de90b525e1c06118aeb02}} 
\index{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}!AreaRatio@{AreaRatio}}
\index{AreaRatio@{AreaRatio}!tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{AreaRatio}{AreaRatio}}
{\footnotesize\ttfamily float \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}{tainicom.\+Aether.\+Physics2\+D.\+Collision.\+Dynamic\+Tree}}$<$ T $>$.Area\+Ratio\hspace{0.3cm}{\ttfamily [get]}}



Get the ratio of the sum of the node areas to the root area. 

\mbox{\Hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_ac5973aefbe658d2fc285fc1fba3e4426}\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_ac5973aefbe658d2fc285fc1fba3e4426}} 
\index{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}!Height@{Height}}
\index{Height@{Height}!tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{Height}{Height}}
{\footnotesize\ttfamily int \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}{tainicom.\+Aether.\+Physics2\+D.\+Collision.\+Dynamic\+Tree}}$<$ T $>$.Height\hspace{0.3cm}{\ttfamily [get]}}



Compute the height of the binary tree in O(\+N) time. Should not be called often. 

\mbox{\Hypertarget{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a6e68eb87b6fd9f4cddf818d014c5de62}\label{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree_a6e68eb87b6fd9f4cddf818d014c5de62}} 
\index{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}!MaxBalance@{MaxBalance}}
\index{MaxBalance@{MaxBalance}!tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$@{tainicom.Aether.Physics2D.Collision.DynamicTree$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{MaxBalance}{MaxBalance}}
{\footnotesize\ttfamily int \mbox{\hyperlink{classtainicom_1_1_aether_1_1_physics2_d_1_1_collision_1_1_dynamic_tree}{tainicom.\+Aether.\+Physics2\+D.\+Collision.\+Dynamic\+Tree}}$<$ T $>$.Max\+Balance\hspace{0.3cm}{\ttfamily [get]}}



Get the maximum balance of an node in the tree. The balance is the difference in height of the two children of a node. 



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
Physics2\+D/\+Collision/Dynamic\+Tree.\+cs\end{DoxyCompactItemize}
